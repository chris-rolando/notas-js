# Notas Javascript ü§ò

keys: 
 code üßë‚Äçüíª
 nota ü¶ñ
 hack ü§ñ
 bookmark üö©

# Bases

## ¬øQue es JS?
 Es un leguaje para programar aplicaciones web.
 ü¶ñ Da dinamismo a la web.

 ### Caracteristicas:
  - Din√°mico.
  - Interpretado.
  - Orientado a objetos.
  - D√©bilmente tipado.

**Operadores:**
- asignaci√≥n "="
- igualdad "=="
- mismo valor y tipo "==="
- disyunci√≥n: AND &&
- uni√≥n: OR ||
- diferente valor o tipo: !==

**Var**
"Var" da problemas! ü¶ñ por el scope global.

**Plantillas literales - template strings!** üö©
En windows usar: alt+96 ü¶ñ 
üßë‚Äçüíª console.log(`Hola ${nombre}`);

## Coerci√≥n - casteo
 **convertir un valor de un tipo de dato a otro tipo.** ü¶ñ
  
 ### conversi√≥n autom√°tica o impl√≠cita
  - üßë‚Äçüíª 
   ```
   const number = 10;
   const string = number; // La variable `string` ahora contiene la cadena "10"
   ```
  
 ### casteo
  - conversi√≥n expl√≠cita ( usando funciones )
  - üßë‚Äçüíª 
   ```
   const number = 10;
   const string = "10";
   const castedNumber = Number(string); // La variable `castedNumber` ahora contiene el n√∫mero 10
   ```

## Truthy & falsy
 Valores verdaderos y falsos:
 - 0, "", NaN, undefined o null.
 - Todo valor que no sea falsy es truthy incluyendo las estructuras vac√≠as de array y objetos:   
  - Boolean([]), Boolean({}) // true.
 
## Bloque try-catch
 Captura un error en caso de que ocurra
 
 üßë‚Äçüíª
  ```
  try { //C√≥digo a probar
  } catch (error) { //C√≥digo en caso de error
  console.log(error);   }

  ```
 **finally** ejecuta la instrucci√≤n sin importar el resultado 

## throw new Error
Crea un nuevo objeto de error con un mensaje.
üßë‚Äçüíª
 ```
  try {
      const num = 100;
      if (num > 50) {
          throw new Error("El n√∫mero es mayor a 50");
      }
  } catch (error) {
      console.error(error.message);
  }
  ```

## Debugging ü§ñ
Encontrar y corregir errores, se utiliza para **detener la ejecuci√≥n** del c√≥digo en un punto espec√≠fco.
üßë‚Äçüíª
 ```
 let numero = 5;
 debugger;
 ```

**Modo estricto:** Conjunto de *reglas y caracter√≠sticas* que proporcionan *mayor seguridad y control* en el c√≥digo.

**this:** se refiere al objeto actual en el que se est√° ejecutando el c√≥digo. depende de su contexto.
 
**CamelCase:**
Usar:
 1. let, const, function: **miNombreEs**
 2. class: **MiClaseEs**

---

# Funciones

## Funcion Declarativa üö©

 Funcion "normal" ü¶ñ
 
 ### Ejemplo: üßë‚Äçüíª 
  ```
  function sumar( a, b ) {
      return a + b;
  }
  sumar( a, b );
  ```

## Funcion de Expresion

 Se definen "como una expresi√≥n!" ü¶ñ
 Puede ser asignada a una variable ü§ñ
 
 ### Ejemplo: üßë‚Äçüíª 
  `let sumar= function (a,b){ return a + b }`

### IIFE (Immediately Invoked Function Expression)

 Funci√≥n que se **autoejecuta inmediatamente despu√©s de ser definida**.
 - Es an√≥nima!
 - No se puede reutilizar!

 ### Ejemplo: üßë‚Äçüíª 
  ```
  (function () {
  console.log("Soy una funcion");
  })();
  ```

### Funcion Flecha - Arrow function üö©
 Funciones de **una sola l√≠nea**. ü¶ñ
 (argumentos) => expresi√≥n que se eval√∫a y se devuelve

 ### Ejemplo: üßë‚Äçüíª 
  ```
  const saludar = () => console.log("Hola");
  saludar();
  ```

## Extra ü§ñ 
- **funciones declarativas se mueven al principio** del √°mbito por lo que se pueden llamar antes de su definici√≥n.
- **funciones de expresi√≥n NO se elevan** por lo que solo se pueden llamar despu√©s de su definici√≥n.
- **funciones declarativas tienen alcance de funci√≥n**.
- **funciones de expresi√≥n tienen alcance de variable**.

---

# Scope ( Ambito de aplicacion )

Determina el alcance o **accesibilidad que tiene cada variable**. ü¶ñ
3 tipos:
- Function scope
- Global scope 
- Block scope

**Block scope:**
Las variables pueden ser accedidas desde el bloque.
El codigo que est√° dentro de {}.

## Extra ü§ñ 
- Usar la menor cantidad posible de variables globales.

---

# Hoisting ( Elevaci√≥n )

Se da cuando las declaraciones de variables y funciones son **desplazadas a la parte superior del scope m√°s cercano**. 
ü¶ñ Ya sea el script actual o funci√≥n actual 

## Ejemplo: üßë‚Äçüíª   
 ```
 console.log(name); // undefined
 var name = "Bard";

 console.log(greet()); // "Hola, Bard!"
 function greet() {
  return "Hola, Bard!";
 }
 ```
 - La variable name y la function greet se utilizan antes de ser declarada. 
 - Esto produce un error?
 - No, ya que JS hoistea la declaraci√≥n.

## Extra ü§ñ 
- Solo funciona con las declaraciones de variables y funciones.
- Si es posible, tratar de declarar variables en el top.

---

# typeof
Se utiliza para devolver el tipo de datos de un valor.

üßë‚Äçüíª 
 ```
 console.log(`typeof 007`);
 typeof "John"                 // Returns "string"
 ```

## Para comprobar o verificar

Por ejemplo: 
- si un valor es un objeto o funci√≥n
- el tipo de datos antes de realizar una operaci√≥n 
üßë‚Äçüíª
 ```
 const value = 25;
 
 if (typeof value === "number") {
   // Realizar la operaci√≥n
 } else {
   // Lanzar un error
 }
 ```

---

# JSON ( JavaScript Object Notation )

Formato para almacenar y transportar datos desde el server.
- "key":value,

üßë‚Äçüíª ` '{"name":"Chris", "age":30}' `

**JSON.stringify()** Convierte un objeto en una cadena de texto JSON.

**JSON.parse()** Los datos se convierten a object o array 
  
 ## Dates
 üßë‚Äçüíª 
  ```
   // usando callback para leer dates 
   const text = '{"name":"John", "birth":"1986-12-14", "city":"New York"}';
   const obj = JSON.parse(text, function (key, value) {
     if (key == "birth") {
       return new Date(value);
     } else {
       return value;
     }
   });
    
   document.getElementById("demo").innerHTML = obj.name + ", " + obj.birth;
 ```

---

# 4- Estructuras de control

## Condicionales
- **Seleccion unica**
- üßë‚Äçüíª 
 ```
 const number = 15;
 
 if (number > 10) {
   const result = "Mayor que 10";
 } else {
   const result = "Menor o igual que 10";
 }
 
 console.log(result); // "Mayor que 10"
 ```

## üö© Operador ternario
- evaluar una condici√≥n y devolver un valor en funci√≥n del resultado
- condicion ? valor_si_verdadero : valor_si_falso;
- üßë‚Äçüíª `const result2 = number > 10 ? "Mayor que 10" : "Menor o igual que 10";`

## switch
- **Selecci√≥n multiple**

## loops
### for
- ü¶ñ **Conocemos la cantidad** de repeticiones.
- üßë‚Äçüíª
  ```
  for (var num = 1; num <= 10; num++) {
  console.log(i)
  }
  ```

### üö© for ‚Ä¶ of
- Para recorrer los valores de los elementos de un array.
- üßë‚Äçüíª
  ```
  let miArray = [5, 4, 3, 2, 1]
  for (let elemento of miArray) {
   console.log(elemento)
  }
  ```

ü¶ñ Solo accede al valor de cada uno de los elementos. Si quieres cambiar el array original se puede usar un array auxiliar!

### While
ü¶ñ **No conocemos la cantidad de repeticiones**.
while (condici√≥n) {
 // Bloque de c√≥digo
}

---

# 5- Closures 

## üö© Definicion

- ü¶ñ Es la combinaci√≥n entre una funci√≥n y el √°mbito en el que esta fue declarada.
- ü¶ñ Permite a las funciones recordar el estado de su entorno de ejecuci√≥n.
- ü§ñ Un closure se crea cuando una funci√≥n es declarada dentro de otra funci√≥n.
- Se usa para crear funciones gen√©ricas y reutilizables.

- üßë‚Äçüíª
  ```
  function counter() {
  let count = 0;
  return function increment() {
      count++;
      return count;
  }
  }
  const myCounter = counter();
  console.log(myCounter()); // Output: 1
  console.log(myCounter()); // Output: 2
  console.log(myCounter()); // Output: 3

  // otro ejemplo -> caso de uso üê≤

  // function moneyBox(coins) {
  //   let saveCoins = 0;
  //   saveCoins += coins;
  //   console.log(`MoneyBox: $${saveCoins}`);
  // }

  // moneyBox(5);
  // moneyBox(5);

  function moneyBox() {
  let saveCoins = 0;
  function countCoins(coins) {
      saveCoins += coins;
      console.log(`MoneyBox: $${saveCoins}`)
  }
  return countCoins;
  }

  const myMoneyBox = moneyBox();
  myMoneyBox(5);
  myMoneyBox(5);
  myMoneyBox(15);

  const moneyBoxAna = moneyBox();
  moneyBoxAna(10);
  moneyBoxAna(20);
  moneyBoxAna(5);

  //otro m√°s

  functionshoppingCart(){
      let cart = [];
      functionaddItems(item){
          cart.push(item);
          console.log(cart);
      }
      return addItems;
  }

  const amazon = shoppingCart();
  amazon("Mouse");
  amazon("Keyboard");
  amazon(`Display 24"`);
  ```

## √Åmbito l√©xico

- Se refiere al alcance de una variable siguiendo la cadena de scopes.

## Higher-Order Functions

- ü§ñ Es una funci√≥n que toma una o m√°s funciones como argumentos y/o devuelve una funci√≥n como resultado.
- Permiten abstraer conceptos comunes en las operaciones de las funciones y permiten la reutilizaci√≥n de c√≥digo.
- map() recibe una funci√≥n como argumento y la aplica a cada elemento de un array retornando un nuevo array.
- Otros ejemplos son: filter(), reduce(), forEach(), sort() y find().

- üßë‚Äçüíª
  ```
  const numbers = [1, 2, 3, 4, 5];
  const doubledNumbers = numbers.map(function(number) {
  return number * 2;
  });
  console.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]
  console.log(numbers) // Output: [1, 2, 3, 4, 5]
  ```

---
# 6- Objetos

## Definici√≥n:

- ü¶ñ Es una estructura de datos.
- Objeto es una representaci√≥n de la realidad, en el cual sus caracter√≠sticas propias se definen como atributos y sus acciones se definen como m√©todos.
- Se define claves: **nombre: valor**.

- üßë‚Äçüíª

  ```
  // declarar
  let miAuto = {
      marca: "Toyota",
      modelo: "Corolla",
      "a√±o": 2023,
      detalle: function () {
          console.log("Es un automovil ")
      }
  }
  ```

- ü¶ñ Excepto por los primitivos y las funciones, todo es un objeto.

## Acceder al objeto

1. **Notacion de corchetes**: `objeto["marca"];`
2. **Notacion de punto**: `miAuto.marca;`

## Constructor

- Sirve para crear varios objetos a partir de nueva informaci√≥n.

- üßë‚Äçüíª
  ```
  function Auto(brand, model, year){
      this.marca = brand
      this.modelo = model
      this.a√±o = year
      this.detalle = function () {
          console.log(`Auto ${this.modelo} del ${this.a√±o}.`)
      }
  }
  var miAuto = new Auto("Toyota", "Corolla", 2020)
  var otroAuto = new Auto("Tesla", "Model 3", 2021)
  var otroAuto2 = new Auto("Suzuki", "K-20", 2019)
  var otroAuto3 = new Auto("Ferrari", "Model N", 2018)
  ```

## Objetos literales

- Son una forma de almacenar y manipular datos en el lenguaje. 
- Pueden contener cualquier tipo de dato, funciones y otros objetos.

### Object.assign()
- Este m√©todo permite copiar las propiedades de un objeto a otro. Por ejemplo:

- üßë‚Äçüíª
  ```
  const objeto1 = {a: 1, b: 2};
  const objeto2 = {c: 3, d: 4};

  // Object.assing necesita de entrada un target al cual asignarle los valores
  // En este ejemplo el target ser√° un nuevo objeto vac√≠o
  // Y los siguientes elementos ser√°n las fuentes (que pueden ser varios objetos)
  
  const nuevoObjeto = Object.assign({}, objeto1, objeto2);
  console.log(nuevoObjeto); // Output: {a: 1, b: 2, c: 3, d: 4}
  ```

### Object.freeze()
- Este m√©todo congela un objeto, impidiendo que sus propiedades sean modificadas. Por ejemplo:

- üßë‚Äçüíª
  ```
  const objeto = {a: 1, b: 2};
  Object.freeze(objeto);
  objeto.a = 3;

  console.log(objeto.a); // Output: 1
  ```

### Object.getOwnProperties
- Este m√©todo devuelve un array con todas las propiedades de un objeto que son de su propiedad (no heredadas) 

- üßë‚Äçüíª
  ```
  const objeto1 = {a: 1, b: 2};
  const objeto2 = Object.create(objeto1);
  objeto2.c = 3;

  console.log(Object.getOwnProperties(objeto2)); // Output: ["c"]
  ```

### Iterar sobre las propiedades de un objeto

1. Bucle for-in. 
  
  - üßë‚Äçüíª
  ```
  const objeto = {a: 1, b: 2, c: 3};
  for (let propiedad in objeto) {
  console.log(propiedad); // Output: "a", "b", "c"
  }
  ```

2. Object.keys() & un bucle for-of

- üßë‚Äçüíª
  ```
  const objeto = {a: 1, b: 2, c: 3};
  const propiedades = Object.keys(objeto);

  // Object.keys da un array con las keys del objeto

  for (let propiedad of propiedades) {
  console.log(propiedad); // Output: "a", "b", "c"
  }
  ```

### Object.values()
- Este m√©todo devuelve un array con los valores de todas las propiedades de un objeto, incluyendo las heredadas

- üßë‚Äçüíª
  ```
  const objeto1 = {a: 1, b: 2};
  const objeto2 = Object.create(objeto1);
  objeto2.c = 3;
  console.log(Object.values(objeto2)); // Output: [3, 1, 2]
  ```

### Object.entries()

- Este m√©todo devuelve un array con los pares clave-valor de todas las propiedades de un objeto, incluyendo las heredadas.

- üßë‚Äçüíª
  ```
  const objeto1 = {a: 1, b: 2};
  const objeto2 = Object.create(objeto1);
  objeto2.c = 3;

  console.log(Object.entries(objeto2)); // Output: [["c", 3], ["a", 1], ["b", 2]]
  ```

### hasOwnProperty()
- Este m√©todo devuelve un booleano indicando si un objeto tiene una propiedad espec√≠fica que es de su propiedad (no heredada)

- üßë‚Äçüíª
  ```
  const objeto1 = {a: 1, b: 2};
  const objeto2 = Object.create(objeto1);
  objeto2.c = 3;

  console.log(objeto2.hasOwnProperty("c")); // Output: true
  console.log(objeto2.hasOwnProperty("a")); // Output: false
---

# ü§ò üê≤ 7 Array

## Defici√≥n

- Es una estructura de datos
- Es un tipo de objeto
- ü¶ñ Sirve para **almacenar colecciones de datos**.

##  Declarar e inicializar?

- üßë‚Äçüíª
  ```
  let myInts = new Array();
  myInts = [5,0,6];

  let myStrings = ["blue", "white", "red"];

  let myNames = ["Chris", "Gaby", "Amanda"];

  let store = [
      { product: "Bike", price: 1500 },
      { product: "TV", price: 1800 },
      { product: "Book", price: 50 }
      ]
  ```

## Const array[]
- se permite cambiar los elementos de un array. pero no re declararlo

## ü§ñ indexOf()

- Encontrar la posici√≥n de un valor espec√≠fico
- Si no se encuentra retorna -1.
- myInts.indexOf(2);

## forEach()

- ü¶ñ Ejecutar una funci√≥n para cada uno de los elementos.
- ü§ñ **No retorna ning√∫n valor.**
- üßë‚Äçüíª  
  ```
  store.forEach(function (store) {
  console.log(store.product);
  })
  ```

## ü§ñ M√©todos mutables

- ü¶ñ Modifican el array (es decir **cambian su estado actual**)

### push() - agregar 
  `myInts.push(7); 
  console.log(myInts);// [ 5, 0, 6, 7 ]`
### unshift() - agregar
  `myInts.unshift(0); 
  console.log(myInts);// [0, 5, 0, 6]`
### pop() - eliminar
  `myInts.pop(); 
  console.log(myInts);// [ 5,0 ]`
### shift() - eliminar
  `myInts.shift(); 
  console.log(myInts);// [ 0,6 ]`

### M√°s metodos

- splice(): agrega o elimina elementos del array.
- sort(): ordena los elementos del array.
- reverse(): invierte el orden de los elementos del array.
- fill(): rellena todos los elementos del array con un valor espec√≠fico.
- copyWithin(): copia una parte del array y la pega en otra parte del mismo array.

## ü§ñ M√©todos inmutables

- ü¶ñ **Crean un nuevo array!**

###  filter()

- ü¶ñ Crea un nuevo array con todos los elementos que pasan una condici√≥n especificada en una funci√≥n.

- üßë‚Äçüíª
  ```
  let workingFilter = articulos.filter(function (articulo) {
  return articulo.costo <= 500
  })

  console.log(workingFilter)
  ```

### map()

ü¶ñ Crea un nuevo array con los resultados de llamar a una funci√≥n para cada elemento del array original.

- üßë‚Äçüíª
  ```
  let workingMap = articulos.map(function (articulo) {
  return articulo.nombre
  })
  console.log(workingMap)
  ```

### find()

- **Encontrar el primer elemento de un array que cumpla con la condici√≥n**.
- Si ning√∫n elemento cumpla con la condici√≥n, retornar√° undefined.

- üßë‚Äçüíª
  ```
  var workingFind = articulos.find(function (articulo) {
  return (articulo.nombre = "Laptop")
  })
  console.log(workingFind)
  ```

### some()

- ü¶ñ Retornar un valor l√≥gico verdadero si existe al menos un elemento que cumpla la condici√≥n.

- üßë‚Äçüíª
  ```
  let workingSome = articulos.some(function (articulo) {
  return articulo.costo <= 700
  })
  console.log(workingSome)
  ```

### M√°s metodos

- concat(): **une** dos o m√°s arrays en uno nuevo.
- slice(): devuelve una **copia de una parte** del array original.
- every(): devuelve **true si todos** los elementos del array pasan la condici√≥n especificada en una funci√≥n.
- findIndex(): devuelve el **√≠ndice del primer elemento del array** que pasa la condici√≥n especificada en una funci√≥n.
  reduce(): aplica una funci√≥n acumuladora a cada elemento del array, y devuelve un √∫nico valor.
  reduceRight(): aplica una funci√≥n acumuladora a cada elemento del array en orden inverso, y devuelve un √∫nico valor.

## Copiar array

### Array.from()

- Crear un nuevo array en base de un objeto.
- üßë‚Äçüíª `let myArray = Array.from('hello');
console.log(myArray); // ["h", "e", "l", "l", "o"]`

### Array(n).fill()

- Llenar un array con un valor espec√≠fico
- üßë‚Äçüíª `let myArray = new Array(5).fill(0);
console.log(myArray); // [0, 0, 0, 0, 0]`

### Array.isArray()

- Determinar si un objeto es un array o no.
- üßë‚Äçüíª `let myArray = [1, 2, 3, 4];
console.log(Array.isArray(myArray)); // true`

### spread operator

- üßë‚Äçüíª `const originalArray = [1, 2, 3, 4];
const copiedArray = [...originalArray];
console.log(originalArray === copiedArray); // Output: false `

## Arrays Bidimensionales

- Son un tipo de estructura de datos en la que cada elemento es un array y cada uno de esos arrays contiene m√°s elementos (son arrays de arrays).

- üßë‚Äçüíª 
  ```
  const matrix = [];
  matrix[0] = [1, 2, 3];
  matrix[1] = [4, 5, 6];
  matrix[2] = [7, 8, 9];
  console.log(matrix);
  ```

## Array.protoype.includes()

- Es una funci√≥n para determinar si un elemento existe en un array. Sin tener que recorrer todo el array.

- Recibe dos par√°metros: 
  1. El elemento que se quiere buscar
  2. El √≠ndice desde donde se iniciar√° la b√∫squeda. Si no se proporciona comenzar√° desde el √≠ndice 0.

- Retorna un valor booleano 
  - Si el elemento se encuentra ser√° true
  - Sino el valor ser√° false.

- üßë‚Äçüíª
  ``` 
  const numbers = [1, 2, 3, 4, 5];

  const result = numbers.includes(3);

  console.log(result); // true
  ```

- ü¶ñ el m√©todo tambi√©n puede buscar objetos y otros tipos de datos. Sin embargo, se realiza utilizando la comparaci√≥n de igualdad estricta "==="
  - S√≥lo se considerar√°n iguales dos objetos si se refieren a la misma ubicaci√≥n en memoria.

## Array.protoype.join()

- Convertir todos los elementos de un array en un solo string.
- Recibe como argumento un separador, que es una cadena de texto que se utilizar√° para separar los elementos del arreglo en el string resultante.

- üßë‚Äçüíª
  ``` 
  const fruits = ["apple", "banana", "cherry"];

  const fruitsString = fruits.join(", ");

  console.log(fruitsString); // "apple, banana, cherry"
  ``` 

- ü¶ñ El separador es (, ) pero podemos usar cualquier otro. Si no se proporciona un separador, se usar√° una coma (,).
- ü¶ñ No modifica directamente el arreglo original, sino que retorna una nueva cadena de texto con los elementos del array original.

## Array.prototype.flat()

- Combinar varios arreglos en un solo arreglo (sin niveles adicionales de anidamiento). 

- Puede aceptar un argumento opcional, que indica la profundidad de anidamiento m√°xima hasta la cual se deben aplanar los arreglos.

- üßë‚Äçüíª
  ``` 
  const multiDimensionalArray = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

  const flatArray = multiDimensionalArray.flat();
  //const flatArray = multiDimensionalArray.flat(1); en este caso indica el valor opcional

  console.log(flatArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
  ``` 
  
## Array.prototype.flatMap()

- Combina Array.prototype.map() y Array.prototype.flat(). 
  - Para transformar cada elemento del arreglo, luego aplana el resultado hasta obtener un √∫nico arreglo con los elementos resultantes.

- Recibe una funci√≥n que se aplicar√° a cada elemento del arreglo. La funci√≥n aplicada a cada elemento devuelve un nuevo arreglo, y flatMap aplana este arreglo resultante en un √∫nico arreglo.

- üßë‚Äçüíª
  ``` 
  const numbers = [1, 2, 3, 4];

  const result = numbers.flatMap(x => [x, x * 2]);

  console.log(result); // Output: [1, 2, 2, 4, 3, 6, 4, 8]
  ``` 

- ü§ñ flatMap tambi√©n puede ser √∫til para eliminar elementos null o undefined de un arreglo

- üßë‚Äçüíª
  ``` 
  const values = [1, 2, 3, null, 4, undefined, 5];

  const result = values.flatMap(x => x);

  console.log(result);
  // Output: [1, 2, 3, 4, 5]
  ``` 
---

# ü§ò 8 Asincronismo

- ü§ñ Las operaciones no bloquean el hilo de ejecuci√≥n principal. por lo que varias operaciones pueden ocurrir al mismo tiempo sin afectar el rendimiento del programa.

## Promesas

- Permiten que una funci√≥n as√≠ncrona devuelva un valor que **estar√° disponible en el futuro**, de manera exitosa (resolve) o con un error (reject).

### promesa simple
- üßë‚Äçüíª
  ```
  const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
  resolve(42);
  }, 2000);
  });
  ```

### Usando then
- üßë‚Äçüíª
  ```
  const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
  resolve({ number: 42, text: "hello" });
  }, 2000);
  });
  promise
  .then((result) => {
  const doubledNumber = result.number \* 2;
  return doubledNumber.toString();
  })
  .then((result) => {
  console.log(`The result is ${result}`);
  })
  .catch((error) => {
  console.error(error);
  });
  ```

## setInterval y setTimeout

- Los temporizadores para programar tareas para que se ejecuten en el futuro.
- son funciones asincr√≥nicas!

### setTimeout

- Permite programar una tarea para que se ejecute despu√©s de un cierto per√≠odo (milisegundos)
- üßë‚Äçüíª
  ```
  setTimeout(() => {
  console.log('Han pasado 5 segundos');
  }, 5000);
  ```

- setTimeout() retorna un identificador √∫nico (un n√∫mero) que puede ser utilizado para cancelar el temporizador antes de que se ejecute. Con la funci√≥n clearTimeout() y pasarle el identificador como argumento.

- üßë‚Äçüíª
  ```
  let id = setTimeout(() => {
  console.log('Han pasado 5 segundos');
  }, 5000);

  // Cancelar el temporizador
  clearTimeout(id);
  ```

### setInterval

- Para programar una tarea para que se repita en un intervalo de tiempo determinado.

- üßë‚Äçüíª
  ```
  setInterval(() => {
  console.log('Han pasado 2 segundos');
  }, 2000);
  ```

## Callback

- Son funciones que se pasan como argumentos a otra funci√≥n y se llaman en alg√∫n momento despu√©s de que se complete la operaci√≥n as√≠ncrona.
- üßë‚Äçüíª
  ```
  function getUserData(userId, callback) {
  fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
    .then(response => response.json())
    .then(data => callback(data))
    .catch(error => console.log(error))
    }

    function displayUserData(data) {
    console.log(data.name);
    }

    getUserData(1, displayUserData);
  ```

### Antipatron Callback Hell

- üßë‚Äçüíª
  ```
  operation1(function(result1) {
  operation2(result1, function(result2) {
      operation3(result2, function(result3) {
      operation4(result3, function(result4) {
          // ...continuar con m√°s operaciones
      });
      });
  });
  });
  ```

- Solucion: utilizar Promesas o Async/Await, que proporcionan una forma m√°s estructurada y f√°cil de leer para manejar c√≥digo as√≠ncrono. 

- üßë‚Äçüíª
  ```
  operation1()
  .then(result1 => {
      return operation2(result1);
  })
  .then(result2 => {
      return operation3(result2);
  })
  .then(result3 => {
      return operation4(result3);
  })
  .then(result4 => {
      // ...continuar con m√°s operaciones
  })
  .catch(error => {
      // Manejar errores
  });
  ```

- En este ejemplo, cada operaci√≥n devuelve una Promesa que se encadena usando el m√©todo then(). Esto hace que el c√≥digo sea m√°s legible y f√°cil de seguir en comparaci√≥n con la versi√≥n anterior.

## Async/await
- En lugar de usar callbacks anidados, async/await permite que el c√≥digo parezca m√°s secuencial y f√°cil de leer.

- üßë‚Äçüíª
  ```
  async function getUserData(userId) {
  try {
  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
  const data = await response.json();
  return data;
  } catch (error) {
  console.log(error);
  }
  }

  async function displayUserData(userId) {
  const data = await getUserData(userId);
  console.log(data.name);
  }

  displayUserData(1);
  ```

- En este ejemplo, se define una funci√≥n getUserData que hace la misma llamada a la API que en el ejemplo anterior, pero esta vez usa await para esperar la respuesta y el try/catch para manejar los errores. La funci√≥n displayUserData tambi√©n utiliza await para esperar que se resuelva la promesa retornada por getUserData y luego muestra el nombre del usuario en la consola.

---


# Regular Expressions ( regex )

Es una secuencia de caracteres para buscar y remplazar.

**search()** Busca una cadena para un valor especificado y devuelve la posici√≥n de la coincidencia.

**replace()** Reemplaza un valor con otro valor en una cadena.

---

# Workin area

---

# ü§ò Hands on


## Incorporar JS al proyecto

En el HTML agregar el link al **final**

<script src="./script.js"></script>

## Seleccionar elementos

Obtener datos desde el HTML:

- üßë‚Äçüíª `const input1 = document.querySelector("#calculo1");`

## Modificar el HTML

Modificar el DOM

- üßë‚Äçüíª `h1.innerHTML = 'Practicando JS';`

Modificar atributos

- üßë‚Äçüíª `h1.setAttribute('class', 'mySecondClass')`

Agregar una clase

- üßë‚Äçüíª `h1.classList.add(mySecondClass);`

addEventListener()

üßë‚Äçüíª
  ```
  btn.addEventListener("click", sumarInputValues);

  function sumarInputValues(event) {
      pResult.innerText = "Resultado: " + input1.value + input2.value;;
  }
  ```
---



# Display
- innerHTML: modificar el contenido existente
- document.write(): escribe en el flujo ( ü¶ñ agregar contenido )




# Notas üö©

- ampliar "Error Object"

